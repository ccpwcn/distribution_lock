# 说明
etcd是新一代的服务发现与配置中心，官网 https://etcd.io/ ，同时兼顾有Redis的部分功能，可以以K-V模式存储数据。

基于它（类似于Zookeeper）实现一套稳定、可靠、强一致的分布式锁，在以后的应用开发中大有用处。

# 开发
这个分布式锁组件依赖于`go.etcd.io/etcd/client/v3`。

# 实现原理
它的实现原理和基于zookeeper的实现原理本质上是一样的：
- 在分布式多进程环境下，锁不能设在进程中，因为两个服务是两个进程，甚至在两台计算机上
- 和集中式锁相比，分布式锁可以支持并发环境下，尤其是高并发环境下的一些数据竞争问题
- 进程1先与etcd建立连接，基于该连接设置k-v的值和版本号，形成一把锁
- 进程1对该连接不断进行续命，只要当前连接没有断开（调用release方法之前），就一直连着
- 如果进程1锁主动释放了（明确调用了release方法），连续不再续命
- 在此期间另外的进程2申请锁，与etcd建立连接
- 进程2基于该连接设置k-v的值和版本号，设置失败
- 如果进程1在锁没有释放之前意外中止了（崩溃了、被kill掉了等等），它的锁不再续命，连接被释放，其他进程此时可申请到锁

> Tips：无论如何，申请锁和释放锁的操作成对出现是个好习惯，只申请不释放的做法不值得提倡。

# 亲测可用
- 锁名相同，竞争测试通过，只会有一个进程获得锁
- 锁名不同，各不影响，各走各的业务逻辑

因此可以在不同的业务场景下，分别定义好自己的锁名各自使用，互不影响。